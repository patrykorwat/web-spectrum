#!/usr/bin/env python3
"""
Simple HTTP API Server for GPS Recording and Processing
Uses Python's built-in http.server - no external dependencies
"""

from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import subprocess
import os
import signal
import time
from datetime import datetime
from pathlib import Path
import threading

# Global state
recording_process = None
processing_process = None
current_recording = None
recording_start_time = None
processing_start_time = None
processing_status = ''

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
RECORDINGS_DIR = os.path.join(SCRIPT_DIR, "recordings")

# Recording configuration
# NOTE: GPS L1 C/A signals use 15.345 MHz bandwidth (Â±7.67 MHz from 1575.42 MHz)
# SDRplay hardware max bandwidth is 8 MHz - this captures the main lobe + some sidelobes
RECORDING_CONFIG = {
    'frequency': 1575420000,  # Hz (GPS L1 center: 1575.42 MHz)
    'frequency_mhz': 1575.42,  # MHz
    'sample_rate': 2048000,  # Hz - 2.048 MSPS (optimized for GPS L1 main lobe)
    'sample_rate_msps': 2.048,  # MSPS
    'gain_reduction': 30,  # dB - CRITICAL: Lower gain prevents thermal shutdown!
    'actual_gain': 29,  # dB (59 - gain_reduction) - Tested: 5 min recording stable
    'bandwidth_mhz': 1.536,  # MHz - Captures GPS L1 main lobe (Â±1.023 MHz = 2.046 MHz)
    'format': 'Complex64 (IQ)',
    'duration_default': 300,  # seconds (5 minutes)
    'file_size_per_min_mb': 983,  # MB per minute (2.048 MSPS * 60s * 8 bytes)
    'expected_size_5min_gb': 4.9,  # GB for 5 minutes (5Ã— smaller than 10 MSPS!)
    'tuner': 2,  # RSPduo tuner: 1 (Tuner A) or 2 (Tuner B) - SET THIS TO YOUR ANTENNA PORT!
    'bias_tee': 'ENABLED'  # Bias-T for active antenna power
}

# Ensure recordings directory exists
os.makedirs(RECORDINGS_DIR, exist_ok=True)


def detect_available_device():
    """
    Detect which SDR device is available (SDRplay or RTL-SDR)

    Returns:
        tuple: (device_type, device_info)
            device_type: 'sdrplay', 'rtlsdr', or None
            device_info: dict with device details
    """
    # Try SDRplay first
    detect_script = os.path.join(SCRIPT_DIR, 'detect_sdrplay.py')
    try:
        result = subprocess.run(
            ['python3', detect_script],
            capture_output=True,
            text=True,
            timeout=5
        )
        device_info = json.loads(result.stdout)
        if device_info.get('success') and device_info.get('count', 0) > 0:
            return ('sdrplay', device_info)
    except Exception as e:
        print(f"SDRplay detection failed: {e}")

    # Try RTL-SDR
    try:
        result = subprocess.run(
            ['rtl_test', '-t'],
            capture_output=True,
            text=True,
            timeout=3
        )
        # RTL-SDR outputs to stderr, not stdout
        output = result.stderr if result.stderr else result.stdout

        if result.returncode == 0 and 'Found' in output:
            # Parse RTL-SDR device info
            lines = output.split('\n')
            device_count = 0
            devices = []

            for line in lines:
                if line.startswith('Found') and 'device' in line:
                    # Extract device count
                    import re
                    match = re.search(r'Found (\d+) device', line)
                    if match:
                        device_count = int(match.group(1))
                elif line.strip().startswith('0:'):
                    # Extract first device info
                    devices.append({
                        'index': 0,
                        'name': line.split(':', 1)[1].strip() if ':' in line else 'RTL-SDR'
                    })

            if device_count > 0:
                return ('rtlsdr', {
                    'success': True,
                    'count': device_count,
                    'devices': devices,
                    'type': 'RTL-SDR'
                })
    except Exception as e:
        print(f"RTL-SDR detection failed: {e}")

    return (None, {'success': False, 'count': 0, 'devices': [], 'error': 'No SDR device found'})


class RecordingAPIHandler(BaseHTTPRequestHandler):
    """HTTP request handler for GPS recording API"""

    def _set_headers(self, status=200, content_type='application/json'):
        """Set HTTP response headers with CORS"""
        self.send_response(status)
        self.send_header('Content-Type', content_type)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def do_OPTIONS(self):
        """Handle CORS preflight"""
        self._set_headers()

    def do_HEAD(self):
        """Handle HEAD requests (same as GET but without body)"""
        # For HEAD requests, we need to check if file exists and send headers only
        if self.path.startswith('/gnss/recordings/'):
            filename = self.path.split('/gnss/recordings/')[-1]
            # Remove query parameters (cache busting timestamps)
            filename = filename.split('?')[0]
            filepath = os.path.join(RECORDINGS_DIR, filename)

            if os.path.exists(filepath) and os.path.isfile(filepath):
                # Determine content type
                if filename.endswith('.json'):
                    content_type = 'application/json'
                elif filename.endswith('.png'):
                    content_type = 'image/png'
                elif filename.endswith('.txt') or filename.endswith('.log'):
                    content_type = 'text/plain'
                else:
                    content_type = 'application/octet-stream'

                # Send headers only (no body for HEAD)
                file_size = os.path.getsize(filepath)
                self.send_response(200)
                self.send_header('Content-Type', content_type)
                self.send_header('Content-Length', file_size)
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
            else:
                self.send_response(404)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
        else:
            # For other endpoints, just send headers (no body)
            self._set_headers()

    def do_GET(self):
        """Handle GET requests"""
        global recording_process, processing_process, current_recording, recording_start_time, processing_start_time, processing_status

        if self.path == '/gnss/status':
            # Get current status
            recording_active = recording_process and recording_process.poll() is None
            processing_active = processing_process and processing_process.poll() is None

            # Check if recording exited with error (0 byte file = device in use)
            recording_error = None
            if recording_process and not recording_active and current_recording:
                exit_code = recording_process.returncode
                file_size = os.path.getsize(current_recording) if os.path.exists(current_recording) else 0
                if file_size == 0:
                    recording_error = 'Recording failed - device may be in use by another application'
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Recording failed: 0 bytes written (device in use?)")
                elif exit_code != 0:
                    recording_error = f'Recording exited with code {exit_code}'

            # Check if processing exited with error
            processing_error = None
            if processing_process and not processing_active and processing_start_time:
                exit_code = processing_process.returncode
                if exit_code != 0:
                    processing_error = f'GNSS-SDR exited with code {exit_code}'
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] GNSS-SDR processing failed: exit code {exit_code}")

            status = {
                'recording': {
                    'active': recording_active,
                    'filename': os.path.basename(current_recording) if current_recording else None,
                    'duration': int(time.time() - recording_start_time) if recording_active and recording_start_time else 0,
                    'error': recording_error
                },
                'processing': {
                    'active': processing_active,
                    'duration': int(time.time() - processing_start_time) if processing_start_time else 0,
                    'status': processing_error if processing_error else processing_status,
                    'error': processing_error
                },
                'recordings': []
            }

            # List available recordings
            if os.path.exists(RECORDINGS_DIR):
                for f in sorted(Path(RECORDINGS_DIR).glob('*.dat'), key=os.path.getmtime, reverse=True):
                    size = os.path.getsize(f)
                    status['recordings'].append({
                        'filename': f.name,
                        'size': size,
                        'size_mb': round(size / (1024 * 1024), 2),
                        'modified': datetime.fromtimestamp(os.path.getmtime(f)).isoformat()
                    })

            self._set_headers()
            self.wfile.write(json.dumps(status).encode())

        elif self.path == '/gnss/config':
            # Return recording configuration
            self._set_headers()
            self.wfile.write(json.dumps(RECORDING_CONFIG).encode())

        elif self.path == '/gnss/device-info':
            # Return info for ALL available SDR devices (SDRplay AND RTL-SDR)
            try:
                result = {
                    'success': True,
                    'sdrplay': None,
                    'rtlsdr': None
                }

                # Check SDRplay
                detect_script = os.path.join(SCRIPT_DIR, 'detect_sdrplay.py')
                try:
                    sdr_result = subprocess.run(
                        ['python3', detect_script],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )
                    sdrplay_info = json.loads(sdr_result.stdout)
                    if sdrplay_info.get('success') and sdrplay_info.get('count', 0) > 0:
                        result['sdrplay'] = sdrplay_info
                except Exception as e:
                    print(f"SDRplay detection failed: {e}")

                # Check RTL-SDR
                try:
                    rtl_result = subprocess.run(
                        ['rtl_test', '-t'],
                        capture_output=True,
                        text=True,
                        timeout=3
                    )
                    output = rtl_result.stderr if rtl_result.stderr else rtl_result.stdout

                    if rtl_result.returncode == 0 and 'Found' in output:
                        lines = output.split('\n')
                        device_count = 0
                        devices = []

                        for line in lines:
                            if line.startswith('Found') and 'device' in line:
                                import re
                                match = re.search(r'Found (\d+) device', line)
                                if match:
                                    device_count = int(match.group(1))
                            elif line.strip().startswith('0:'):
                                devices.append({
                                    'index': 0,
                                    'name': line.split(':', 1)[1].strip() if ':' in line else 'RTL-SDR'
                                })

                        if device_count > 0:
                            result['rtlsdr'] = {
                                'success': True,
                                'count': device_count,
                                'devices': devices,
                                'type': 'RTL-SDR'
                            }
                except Exception as e:
                    print(f"RTL-SDR detection failed: {e}")

                self._set_headers()
                self.wfile.write(json.dumps(result).encode())

            except Exception as e:
                self._set_headers(500)
                self.wfile.write(json.dumps({
                    'error': f'Device detection failed: {str(e)}',
                    'sdrplay': None,
                    'rtlsdr': None
                }).encode())

        elif self.path.startswith('/gnss/recordings/'):
            # Serve individual files (spectrum analysis, plots, etc.)
            filename = self.path.split('/gnss/recordings/')[-1]
            # Remove query parameters (cache busting timestamps like ?t=123456789)
            filename = filename.split('?')[0]
            filepath = os.path.join(RECORDINGS_DIR, filename)

            if os.path.exists(filepath) and os.path.isfile(filepath):
                # Determine content type
                if filename.endswith('.json'):
                    content_type = 'application/json'
                elif filename.endswith('.png'):
                    content_type = 'image/png'
                elif filename.endswith('.txt') or filename.endswith('.log'):
                    content_type = 'text/plain'
                else:
                    content_type = 'application/octet-stream'

                # Read and serve file
                with open(filepath, 'rb') as f:
                    file_data = f.read()

                self.send_response(200)
                self.send_header('Content-Type', content_type)
                self.send_header('Content-Length', len(file_data))
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(file_data)
            else:
                self.send_response(404)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'File not found'}).encode())

        elif self.path == '/gnss/recordings':
            # List all recordings
            recordings = []
            if os.path.exists(RECORDINGS_DIR):
                for f in sorted(Path(RECORDINGS_DIR).glob('*.dat'), key=os.path.getmtime, reverse=True):
                    size = os.path.getsize(f)
                    recordings.append({
                        'filename': f.name,
                        'filepath': str(f),
                        'size': size,
                        'size_mb': round(size / (1024 * 1024), 2),
                        'modified': datetime.fromtimestamp(os.path.getmtime(f)).isoformat(),
                        'has_nmea': os.path.exists(str(f).replace('.dat', '.nmea')),
                        'has_kml': os.path.exists(str(f).replace('.dat', '.kml'))
                    })

            self._set_headers()
            self.wfile.write(json.dumps({
                'success': True,
                'recordings': recordings,
                'total': len(recordings)
            }).encode())

        else:
            self._set_headers(404)
            self.wfile.write(json.dumps({'error': 'Not found'}).encode())

    def do_POST(self):
        """Handle POST requests"""
        global recording_process, processing_process, current_recording, recording_start_time

        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length).decode('utf-8') if content_length > 0 else '{}'

        try:
            data = json.loads(post_data)
        except:
            data = {}

        if self.path == '/gnss/start-recording':
            # Start recording
            try:
                duration = data.get('duration', RECORDING_CONFIG['duration_default'])
                # Allow tuner selection from request, fallback to config default
                tuner = data.get('tuner', RECORDING_CONFIG['tuner'])
                # NEW: Explicit device type selection from request
                device_type = data.get('device_type', 'sdrplay')  # Default to sdrplay for backward compatibility

                if recording_process and recording_process.poll() is None:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': 'Recording already in progress'
                    }).encode())
                    return

                # Validate device type
                if device_type not in ['sdrplay', 'rtlsdr']:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': f'Invalid device_type: {device_type}. Must be "sdrplay" or "rtlsdr"'
                    }).encode())
                    return

                # Generate filename
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"gps_recording_{timestamp}.dat"
                filepath = os.path.join(RECORDINGS_DIR, filename)

                # Select recording script based on device type
                if device_type == 'sdrplay':
                    record_script = os.path.join(SCRIPT_DIR, 'sdrplay_direct.py')
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Using SDRplay device for recording")
                elif device_type == 'rtlsdr':
                    record_script = os.path.join(SCRIPT_DIR, 'rtlsdr_direct.py')
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Using RTL-SDR device for recording")

                # Start recording
                env = os.environ.copy()
                env['DYLD_LIBRARY_PATH'] = '/usr/local/lib:' + env.get('DYLD_LIBRARY_PATH', '')
                env['PYTHONUNBUFFERED'] = '1'

                recording_process = subprocess.Popen(
                    [
                        'python3', '-u', record_script,
                        '--output', filepath,
                        '--duration', str(duration),
                        '--sample-rate', str(RECORDING_CONFIG['sample_rate']),
                        '--frequency', str(RECORDING_CONFIG['frequency']),
                        '--gain-reduction', str(RECORDING_CONFIG['gain_reduction']),
                        '--tuner', str(tuner)  # Use selected tuner from request
                    ],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    env=env,
                    universal_newlines=True,
                    bufsize=1
                )

                current_recording = filepath
                recording_start_time = time.time()

                self._set_headers()
                self.wfile.write(json.dumps({
                    'success': True,
                    'filename': filename,
                    'filepath': filepath,
                    'duration': duration,
                    'device_type': device_type,
                    'started_at': timestamp
                }).encode())

            except Exception as e:
                self._set_headers(500)
                self.wfile.write(json.dumps({
                    'success': False,
                    'error': str(e)
                }).encode())

        elif self.path == '/gnss/stop-recording':
            # Stop recording
            try:
                if not recording_process or recording_process.poll() is not None:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': 'No recording in progress'
                    }).encode())
                    return

                # Send SIGINT
                recording_process.send_signal(signal.SIGINT)
                recording_process.wait(timeout=5)

                file_size = 0
                if current_recording and os.path.exists(current_recording):
                    file_size = os.path.getsize(current_recording)

                recording_process = None

                self._set_headers()
                self.wfile.write(json.dumps({
                    'success': True,
                    'filename': os.path.basename(current_recording) if current_recording else None,
                    'file_size': file_size,
                    'file_size_mb': round(file_size / (1024 * 1024), 2)
                }).encode())

            except subprocess.TimeoutExpired:
                recording_process.kill()
                self._set_headers()
                self.wfile.write(json.dumps({
                    'success': True,
                    'warning': 'Recording process killed (timeout)'
                }).encode())
            except Exception as e:
                self._set_headers(500)
                self.wfile.write(json.dumps({
                    'success': False,
                    'error': str(e)
                }).encode())

        elif self.path == '/gnss/process-recording':
            # Process recording with selected decoder (GNSS-SDR or Gypsum)
            global processing_start_time, processing_status
            try:
                filename = data.get('filename')
                decoder = data.get('decoder', 'gnss-sdr')  # Default to GNSS-SDR

                if not filename:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': 'No filename provided'
                    }).encode())
                    return

                # Validate decoder choice
                if decoder not in ['gnss-sdr', 'gypsum']:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': f'Invalid decoder: {decoder}. Must be "gnss-sdr" or "gypsum"'
                    }).encode())
                    return

                filepath = os.path.join(RECORDINGS_DIR, filename)

                # Wait briefly for file to be fully written if it was just created
                if not os.path.exists(filepath):
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] File not found immediately, waiting 2s...")
                    time.sleep(2)

                if not os.path.exists(filepath):
                    self._set_headers(404)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': f'Recording file not found: {filename}'
                    }).encode())
                    return

                # Verify file has reasonable size (at least 1MB)
                file_size = os.path.getsize(filepath)
                if file_size < 1_000_000:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': f'Recording file too small ({file_size} bytes). Recording may have failed.'
                    }).encode())
                    return

                print(f"[{datetime.now().strftime('%H:%M:%S')}] Processing file: {filepath} ({file_size / 1e9:.2f} GB)")
                print(f"[{datetime.now().strftime('%H:%M:%S')}] Using decoder: {decoder}")

                if processing_process and processing_process.poll() is None:
                    self._set_headers(400)
                    self.wfile.write(json.dumps({
                        'success': False,
                        'error': 'Processing already in progress'
                    }).encode())
                    return

                # ============================================================
                # DECODER SELECTION: GNSS-SDR or Gypsum
                # ============================================================

                if decoder == 'gypsum':
                    # Use Gypsum decoder (Python-based GPS receiver)
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Starting Gypsum decoder...")

                    # Check if gypsum_wrapper.py exists
                    gypsum_wrapper = os.path.join(os.path.dirname(SCRIPT_DIR), 'rtl-sdr-gps', 'gypsum_wrapper.py')
                    if not os.path.exists(gypsum_wrapper):
                        raise Exception(f'Gypsum wrapper not found at: {gypsum_wrapper}')

                    output_basename = os.path.join(RECORDINGS_DIR, filename.replace('.dat', ''))

                    # Run Gypsum wrapper
                    cmd = f"python3 {gypsum_wrapper} --input {filepath} --output {RECORDINGS_DIR}"

                    env = os.environ.copy()
                    env['PYTHONUNBUFFERED'] = '1'

                    processing_process = subprocess.Popen(
                        cmd,
                        shell=True,
                        env=env,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        universal_newlines=True,
                        bufsize=1
                    )

                    processing_start_time = time.time()
                    processing_status = 'Gypsum decoding started...'

                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Gypsum decoder started")
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Command: {cmd}")

                    # Start log streaming thread for Gypsum
                    def stream_gypsum_logs():
                        """Stream Gypsum stdout to WebSocket clients"""
                        log_filename = filepath.replace('.dat', '_gypsum.log')
                        log_lines = []

                        try:
                            print(f"[{datetime.now().strftime('%H:%M:%S')}] Streaming Gypsum logs...")

                            with open(log_filename, 'w') as log_file:
                                for line in processing_process.stdout:
                                    log_lines.append(line)
                                    log_file.write(line)
                                    log_file.flush()

                                    # Print to console
                                    print(f"[Gypsum] {line.rstrip()}")

                                    # Stream to WebSocket clients
                                    try:
                                        import requests
                                        requests.post('http://localhost:8766/broadcast', json={
                                            'type': 'gnss_log',
                                            'data': line.rstrip()
                                        }, timeout=0.1)
                                    except:
                                        pass

                            print(f"[{datetime.now().strftime('%H:%M:%S')}] Gypsum log saved to: {log_filename}")

                        except Exception as e:
                            print(f"[{datetime.now().strftime('%H:%M:%S')}] Error streaming Gypsum logs: {e}")

                    threading.Thread(target=stream_gypsum_logs, daemon=True).start()

                    self._set_headers()
                    self.wfile.write(json.dumps({
                        'success': True,
                        'message': 'Gypsum processing started',
                        'filename': filename,
                        'decoder': 'gypsum'
                    }).encode())

                elif decoder == 'gnss-sdr':
                    # Use GNSS-SDR decoder (professional/reference implementation)
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Starting GNSS-SDR decoder...")

                    # Create GNSS-SDR config from template
                    config_path = os.path.join(RECORDINGS_DIR, f"{filename}.conf")
                    output_basename = os.path.join(RECORDINGS_DIR, filename.replace('.dat', ''))

                    # Try to load template file
                    template_path = os.path.join(SCRIPT_DIR, 'gnss_sdr_template.conf')

                    if os.path.exists(template_path):
                        # Use template and customize paths
                        print(f"[{datetime.now().strftime('%H:%M:%S')}] Using template: {template_path}")
                        with open(template_path, 'r') as f:
                            config_content = f.read()

                        # Replace placeholders in template
                        config_content = config_content.replace('SignalSource.filename=', f'SignalSource.filename={filepath}')
                        # Don't add extra slash if RECORDINGS_DIR already ends with /
                        kml_path = RECORDINGS_DIR if RECORDINGS_DIR.endswith('/') else f'{RECORDINGS_DIR}/'
                        gpx_path = RECORDINGS_DIR if RECORDINGS_DIR.endswith('/') else f'{RECORDINGS_DIR}/'
                        config_content = config_content.replace('PVT.kml_output_path=', f'PVT.kml_output_path={kml_path}')
                        config_content = config_content.replace('PVT.gpx_output_path=', f'PVT.gpx_output_path={gpx_path}')
                        config_content = config_content.replace('PVT.nmea_dump_filename=output.nmea', f'PVT.nmea_dump_filename={output_basename}.nmea')

                        # Add signal source filename if not present
                        if 'SignalSource.filename=' not in config_content or f'SignalSource.filename={filepath}' not in config_content:
                            # Insert filename after SignalSource.implementation
                            config_content = config_content.replace(
                                'SignalSource.implementation=File_Signal_Source',
                                f'SignalSource.implementation=File_Signal_Source\nSignalSource.filename={filepath}'
                            )
                    else:
                        # Fallback to hardcoded config if template doesn't exist
                        print(f"[{datetime.now().strftime('%H:%M:%S')}] Template not found, using default config")
                        config_content = f"""; GNSS-SDR Configuration (Auto-generated)
; 2.048 MSPS sample rate for GPS L1 main lobe
[GNSS-SDR]
GNSS-SDR.internal_fs_sps=2048000

SignalSource.implementation=File_Signal_Source
SignalSource.filename={filepath}
SignalSource.item_type=gr_complex
SignalSource.sampling_frequency=2048000
SignalSource.freq=1575420000
SignalSource.samples=0
SignalSource.repeat=false
SignalSource.dump=false
SignalSource.enable_throttle_control=true

Channels_1C.count=8
Channels.in_acquisition=1

Acquisition_1C.implementation=GPS_L1_CA_PCPS_Acquisition
Acquisition_1C.item_type=gr_complex
Acquisition_1C.coherent_integration_time_ms=1
Acquisition_1C.pfa=0.01
Acquisition_1C.doppler_max=5000
Acquisition_1C.doppler_step=250
Acquisition_1C.threshold=0.008

Tracking_1C.implementation=GPS_L1_CA_DLL_PLL_Tracking
Tracking_1C.item_type=gr_complex
Tracking_1C.pll_bw_hz=10.0
Tracking_1C.dll_bw_hz=1.0

TelemetryDecoder_1C.implementation=GPS_L1_CA_Telemetry_Decoder
Observables.implementation=Hybrid_Observables

PVT.implementation=RTKLIB_PVT
PVT.positioning_mode=Single
PVT.output_rate_ms=100
PVT.display_rate_ms=500
PVT.kml_output_enabled=true
PVT.kml_output_path={RECORDINGS_DIR}/
PVT.gpx_output_enabled=true
PVT.gpx_output_path={RECORDINGS_DIR}/
PVT.nmea_dump_filename={output_basename}.nmea
PVT.enable_monitor=true
PVT.monitor_udp_port=1234
"""

                    with open(config_path, 'w') as f:
                        f.write(config_content)

                    # Start GNSS-SDR processing
                    env = os.environ.copy()
                    env['DYLD_LIBRARY_PATH'] = '/usr/local/lib:' + env.get('DYLD_LIBRARY_PATH', '')
                    env['PYTHONUNBUFFERED'] = '1'

                    # Check if gnss-sdr exists
                    try:
                        subprocess.run(['which', 'gnss-sdr'], check=True, capture_output=True)
                    except subprocess.CalledProcessError:
                        raise Exception('gnss-sdr not found in PATH. Install GNSS-SDR first.')

                    # Run GNSS-SDR directly without parse script (it doesn't exist)
                    # Output goes to NMEA/KML files specified in config
                    cmd = f"gnss-sdr --config_file={config_path}"

                    processing_process = subprocess.Popen(
                        cmd,
                        shell=True,
                        env=env,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        universal_newlines=True,
                        bufsize=1
                    )

                    processing_start_time = time.time()
                    processing_status = 'GNSS-SDR processing started...'

                    # Log that processing started
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Starting GNSS-SDR processing:")
                    print(f"  Config: {config_path}")
                    print(f"  Input: {filepath}")
                    print(f"  Output base: {output_basename}")
                    print(f"  PID: {processing_process.pid}")

                    # Start a background thread to stream GNSS-SDR logs to WebSocket AND save to file
                    def stream_logs():
                        """Stream GNSS-SDR stdout to WebSocket clients via bridge and save to log file"""
                        # Create log file for this processing run
                        log_filename = filepath.replace('.dat', '_gnss.log')

                        try:
                            import asyncio
                            import websockets
                            import json as json_lib

                            async def send_logs():
                                ws = None
                                log_file = None

                                try:
                                    # Connect to WebSocket bridge
                                    ws = await websockets.connect('ws://localhost:8766')
                                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Connected to WebSocket bridge for log streaming")
                                except Exception as e:
                                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Warning: Could not connect to WebSocket: {e}")

                                try:
                                    # Open log file for writing
                                    log_file = open(log_filename, 'w', buffering=1)
                                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Saving GNSS-SDR logs to: {log_filename}")
                                except Exception as e:
                                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Warning: Could not open log file: {e}")

                                # Stream logs line by line
                                try:
                                    for line in iter(processing_process.stdout.readline, ''):
                                        if not line:
                                            break

                                        # Print to console
                                        print(f"[GNSS-SDR] {line.rstrip()}")

                                        # Write to log file
                                        if log_file:
                                            log_file.write(line)
                                            log_file.flush()

                                        # Send to WebSocket bridge
                                        if ws:
                                            try:
                                                log_msg = {
                                                    'type': 'gnss_log',
                                                    'message': line.rstrip(),
                                                    'timestamp': datetime.now().isoformat()
                                                }
                                                await ws.send(json_lib.dumps(log_msg))
                                            except Exception as ws_error:
                                                print(f"[{datetime.now().strftime('%H:%M:%S')}] WebSocket send error at receiver time {line.strip()}: {ws_error}")
                                                ws = None  # Mark as disconnected to prevent further errors

                                finally:
                                    if log_file:
                                        log_file.close()
                                        print(f"[{datetime.now().strftime('%H:%M:%S')}] GNSS-SDR log saved to: {log_filename}")
                                    if ws:
                                        await ws.close()

                            # Run async event loop in thread
                            asyncio.run(send_logs())

                        except Exception as e:
                            # Fall back to just printing and saving logs
                            print(f"[{datetime.now().strftime('%H:%M:%S')}] WebSocket error, saving logs to file only: {e}")
                            try:
                                with open(log_filename, 'w', buffering=1) as log_file:
                                    for line in iter(processing_process.stdout.readline, ''):
                                        if line:
                                            print(f"[GNSS-SDR] {line.rstrip()}")
                                            log_file.write(line)
                            except Exception as e2:
                                print(f"[{datetime.now().strftime('%H:%M:%S')}] Could not save logs: {e2}")

                    # Start log streaming thread
                    log_thread = threading.Thread(target=stream_logs, daemon=True)
                    log_thread.start()

                    # Run spectrum analysis in parallel (non-blocking)
                    def run_spectrum_analysis():
                        """Run GPS spectrum analysis for jamming detection"""
                        try:
                            spectrum_script = os.path.join(SCRIPT_DIR, 'gps_spectrum_analyzer.py')
                            if os.path.exists(spectrum_script):
                                print(f"[{datetime.now().strftime('%H:%M:%S')}] Starting spectrum analysis...")

                                # Analyze first 60 seconds with 2.048 MSPS (5Ã— less data than 10 MSPS!)
                                # At 2.048 MSPS: 60s = 122M samples (vs 600M at 10 MSPS)
                                # Memory: FFT=2048, overlap=50% = ~24 MB (vs 117 MB at 10 MSPS)
                                # Processing time: Expected ~2-3 min for full minute
                                spectrum_output = filepath.replace('.dat', '_spectrum_analysis.json')
                                spectrum_plot = filepath.replace('.dat', '_spectrum.png')

                                result = subprocess.run([
                                    'python3', spectrum_script,
                                    filepath,
                                    '--duration', '60',
                                    '--output', spectrum_output,
                                    '--plot', spectrum_plot
                                ], capture_output=True, text=True, timeout=600)  # 10 min timeout

                                # Log any errors
                                if result.returncode != 0:
                                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Spectrum analysis failed:")
                                    print(f"  stdout: {result.stdout}")
                                    print(f"  stderr: {result.stderr}")
                                elif result.stderr:
                                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Spectrum analysis warnings:")
                                    print(f"  {result.stderr}")

                                print(f"[{datetime.now().strftime('%H:%M:%S')}] Spectrum analysis complete: {spectrum_output}")
                        except Exception as e:
                            print(f"[{datetime.now().strftime('%H:%M:%S')}] Spectrum analysis error: {e}")

                    # Start spectrum analysis thread
                    spectrum_thread = threading.Thread(target=run_spectrum_analysis, daemon=True)
                    spectrum_thread.start()

                    self._set_headers()
                    self.wfile.write(json.dumps({
                        'success': True,
                        'config': config_path,
                        'output_base': output_basename,
                        'expected_outputs': [
                            f"{output_basename}.nmea",
                            f"{output_basename}.kml",
                            f"{output_basename}.gpx",
                            f"{output_basename}_spectrum_analysis.json",
                            f"{output_basename}_spectrum.png",
                            f"{output_basename}_spectrum_narrowband.png"
                        ]
                    }).encode())

            except Exception as e:
                self._set_headers(500)
                self.wfile.write(json.dumps({
                    'success': False,
                    'error': str(e)
                }).encode())

        else:
            self._set_headers(404)
            self.wfile.write(json.dumps({'error': 'Not found'}).encode())

    def log_message(self, format, *args):
        """Custom logging"""
        print(f"[{self.address_string()}] {format % args}")


def run_server(port=3001):
    """Run the HTTP server"""
    server_address = ('', port)
    httpd = HTTPServer(server_address, RecordingAPIHandler)

    print("=" * 70)
    print("ðŸ›°ï¸  GPS Recording API Server")
    print("=" * 70)
    print()
    print(f"Recordings directory: {RECORDINGS_DIR}")
    print()
    print("Endpoints:")
    print("  POST /gnss/start-recording   - Start GPS data recording")
    print("  POST /gnss/stop-recording    - Stop current recording")
    print("  POST /gnss/process-recording - Process recorded file")
    print("  GET  /gnss/status            - Get current status")
    print("  GET  /gnss/recordings        - List all recordings")
    print()
    print(f"Server running on http://localhost:{port}")
    print("Press Ctrl+C to stop")
    print("=" * 70)
    print()

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\n\nðŸ›‘ Shutting down server...")
        httpd.shutdown()


if __name__ == '__main__':
    run_server()
